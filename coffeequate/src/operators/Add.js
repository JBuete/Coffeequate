// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(["nodes", "terminals", "AlgebraError", "parseArgs", "require", "compare", "prettyRender"], function(nodes, terminals, AlgebraError, parseArgs, require, compare, prettyRender) {
    var Add, combinations;
    combinations = function(list) {
      var i, ii, results, _i, _j, _len, _len1, _ref, _ref1;
      if (list.length === 1) {
        return (function() {
          var _i, _len, _ref, _results;
          _ref = list[0];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            i = _ref[_i];
            _results.push(i);
          }
          return _results;
        })();
      } else {
        results = [];
        _ref = list[0];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          _ref1 = combinations(list.slice(1));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            ii = _ref1[_j];
            results.push([i].concat(ii));
          }
        }
        return results;
      }
    };
    Add = (function(_super) {
      __extends(Add, _super);

      function Add() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (args.length < 1) {
          throw new Error("Add nodes must have at least one child.");
        }
        this.cmp = -1;
        args = parseArgs.apply(null, args);
        Add.__super__.constructor.call(this, "+", args);
      }

      Add.prototype.copy = function() {
        var args, i;
        args = (function() {
          var _i, _len, _ref, _results;
          _ref = this.children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            i = _ref[_i];
            _results.push(i.copy != null ? i.copy() : i);
          }
          return _results;
        }).call(this);
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Add, args, function(){});
      };

      Add.prototype.compareSameType = function(b) {
        var c, child, index, lengthComparison, _i, _len, _ref;
        if (this.children.length === b.children.length) {
          lengthComparison = 0;
        } else if (this.children.length < b.children.length) {
          lengthComparison = -1;
        } else {
          lengthComparison = 1;
        }
        _ref = this.children;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          child = _ref[index];
          if (b.children[index] == null) {
            return 1;
          }
          c = compare(this.children[index], b.children[index]);
          if (c !== 0) {
            return c;
          }
        }
        return lengthComparison;
      };

      Add.prototype.getVariableUnits = function(variable, equivalencies) {
        var child, childVariableUnits, variableEquivalencies, _i, _len, _ref, _ref1;
        variableEquivalencies = equivalencies != null ? equivalencies.get(variable) : [variable];
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child instanceof terminals.Variable && (_ref1 = child.label, __indexOf.call(variableEquivalencies, _ref1) >= 0)) {
            return child.units;
          } else {
            childVariableUnits = child.getVariableUnits(variable, equivalencies);
            if (childVariableUnits != null) {
              return childVariableUnits;
            }
          }
        }
        return null;
      };

      Add.prototype.setVariableUnits = function(variable, equivalencies, units) {
        var child, variableEquivalencies, _i, _len, _ref, _results;
        variableEquivalencies = equivalencies != null ? equivalencies.get(variable) : {
          get: function(z) {
            return [z];
          }
        };
        _ref = this.children;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          _results.push(child.setVariableUnits(variable, equivalencies, units));
        }
        return _results;
      };

      Add.prototype.expand = function() {
        var add, c, child, children, _i, _j, _len, _len1, _ref, _ref1;
        children = [];
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.expand != null) {
            child = child.expand();
          } else if (child.copy != null) {
            child = child.copy();
          }
          if (child instanceof Add) {
            _ref1 = child.children;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              c = _ref1[_j];
              children.push(c);
            }
          } else {
            children.push(child);
          }
        }
        add = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Add, children, function(){});
        add.sort();
        return add;
      };

      Add.prototype.sort = function() {
        var child, _i, _len, _ref;
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (typeof child.sort === "function") {
            child.sort();
          }
        }
        return this.children.sort(compare);
      };

      Add.prototype.equals = function(b, equivalencies) {
        var child, index, _i, _len, _ref;
        if (!(b instanceof Add)) {
          return false;
        }
        if (b.children.length !== this.children.length) {
          return false;
        }
        _ref = this.children;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          child = _ref[index];
          if (child.equals != null) {
            if (!child.equals(b.children[index], equivalencies)) {
              return false;
            }
          } else {
            if (child !== b.children[index]) {
              return false;
            }
          }
        }
        return true;
      };

      Add.prototype.simplify = function(equivalencies) {
        var Mul, c, child, constantterm, constanttermmul, found, i, index, liketerm, liketerms, newAdd, newMul, term, terms, variabletermmul, _base, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2;
        Mul = require("operators/Mul");
        if (equivalencies == null) {
          equivalencies = {
            get: function(variable) {
              return [variable];
            }
          };
        }
        terms = [];
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.simplify != null) {
            child = child.simplify(equivalencies);
          } else if (child.copy != null) {
            child = child.copy();
          }
          terms.push(child);
        }
        liketerms = [];
        constantterm = null;
        i = 0;
        while (i < terms.length) {
          term = terms[i];
          if (term instanceof Add) {
            terms.splice(i, 1)[0];
            _ref1 = term.children;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              c = _ref1[_j];
              terms.push(c);
            }
            i -= 1;
          } else if (term instanceof terminals.Constant) {
            if (constantterm != null) {
              constantterm = constantterm.add(term);
            } else {
              constantterm = term.copy();
            }
          } else if (term instanceof Mul) {
            constanttermmul = null;
            variabletermmul = null;
            _ref2 = term.children;
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              child = _ref2[_k];
              if (child instanceof terminals.Constant) {
                if (constanttermmul != null) {
                  constanttermmul = constanttermmul.multiply(child);
                } else {
                  constanttermmul = child.copy();
                }
              } else {
                if (variabletermmul != null) {
                  variabletermmul.children.push(child);
                } else {
                  variabletermmul = new Mul(child);
                }
              }
            }
            if (variabletermmul.children.length === 1) {
              variabletermmul = variabletermmul.children[0];
            }
            if ((constanttermmul != null) && (variabletermmul == null)) {
              if (constantterm != null) {
                constantterm = constantterm.add(constanttermmul);
              } else {
                constantterm = constanttermmul.copy();
              }
            } else {
              if (constanttermmul == null) {
                constanttermmul = new terminals.Constant("1");
              }
              found = false;
              for (index = _l = 0, _len3 = liketerms.length; _l < _len3; index = ++_l) {
                liketerm = liketerms[index];
                if (liketerm[0].equals != null) {
                  if (liketerm[0].equals(variabletermmul, equivalencies)) {
                    liketerms[index][1] = new Add(liketerm[1], constanttermmul);
                    liketerms[index][1] = liketerms[index][1].simplify(equivalencies);
                    found = true;
                  }
                } else if (liketerm[0] === variabletermmul) {
                  liketerms[index][1] = new Add(liketerm[1], constanttermmul);
                  liketerms[index][1] = liketerms[index][1].simplify(equivalencies);
                  found = true;
                }
              }
              if (!found) {
                liketerms.push([variabletermmul, constanttermmul]);
              }
            }
          } else {
            found = false;
            for (index = _m = 0, _len4 = liketerms.length; _m < _len4; index = ++_m) {
              liketerm = liketerms[index];
              if (liketerm[0].equals != null) {
                if (liketerm[0].equals(term, equivalencies)) {
                  liketerms[index][1] = new Add(liketerm[1], new terminals.Constant("1"));
                  liketerms[index][1] = liketerms[index][1].simplify(equivalencies);
                  found = true;
                }
              } else if (liketerm[0] === term) {
                liketerms[index][1] = new Add(liketerm[1], new terminals.Constant("1"));
                liketerms[index][1] = liketerms[index][1].simplify(equivalencies);
                found = true;
              }
            }
            if (!found) {
              liketerms.push([term, new terminals.Constant("1")]);
            }
          }
          i += 1;
        }
        newAdd = null;
        for (_n = 0, _len5 = liketerms.length; _n < _len5; _n++) {
          liketerm = liketerms[_n];
          if ((liketerm[0].children != null) && liketerm[0].children.length === 1) {
            liketerm[0] = liketerm[0].children[0];
          }
          if ((typeof (_base = liketerm[1]).evaluate === "function" ? _base.evaluate() : void 0) !== 1) {
            newMul = new Mul(liketerm[0], liketerm[1]);
            newMul = newMul.simplify(equivalencies);
          } else {
            newMul = liketerm[0];
          }
          if (newAdd != null) {
            newAdd.children.push(newMul);
          } else {
            newAdd = new Add(newMul);
          }
        }
        if (newAdd == null) {
          return constantterm;
        }
        if ((constantterm != null) && constantterm.evaluate() !== 0) {
          newAdd.children.push(constantterm);
        }
        newAdd.sort();
        if (newAdd.children.length !== 1) {
          return newAdd;
        }
        return newAdd.children[0];
      };

      Add.prototype.expandAndSimplify = function(equivalencies) {
        var expr;
        expr = this.expand();
        if (expr.simplify != null) {
          return expr.simplify(equivalencies);
        }
        return expr;
      };

      Add.prototype.solve = function(variable, equivalencies) {
        var Mul, Pow, a, a1, a2, added, answer, b, c, d, equiv, expr, factorised, factorisedEquatable, factorisedSquares, factorisedSquaresEquatable, factorisedTerm, inv, invSquare, inversed, inversedEquatable, inversedSquares, inversedSquaresEquatable, negatedTerms, negatedTermsEquatable, newAdd, newMul, newPow, nonNegatedTermsEquatable, power, quadratic, rd, subterm, subterms, term, termsContainingVariable, termsNotContainingVariable, units, v1, v2, variableUnits, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        if (equivalencies == null) {
          equivalencies = null;
        }
        Mul = require("operators/Mul");
        Pow = require("operators/Pow");
        expr = this.expandAndSimplify(equivalencies);
        if (equivalencies == null) {
          equivalencies = {
            get: function(variable) {
              return [variable];
            }
          };
        }
        termsContainingVariable = [];
        termsNotContainingVariable = [];
        variableUnits = null;
        for (_i = 0, _len = equivalencies.length; _i < _len; _i++) {
          equiv = equivalencies[_i];
          units = this.getVariableUnits(equiv);
          if (units != null) {
            variableUnits = units;
            break;
          }
        }
        if (expr instanceof terminals.Terminal) {
          if (expr instanceof terminals.Variable && (expr.label === variable || (_ref = expr.label, __indexOf.call(equivalencies.get(variable), _ref) >= 0))) {
            return [new terminals.Constant("0")];
          } else {
            throw new AlgebraError(expr.toString(), variable);
          }
        }
        if (!(expr instanceof Add)) {
          return expr.solve(variable, equivalencies);
        }
        _ref1 = expr.children;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          term = _ref1[_j];
          if (term.copy != null) {
            term = term.copy();
          }
          if (term instanceof Pow) {
            if (term.children.left instanceof terminals.Variable && (term.children.left.label === variable || (_ref2 = term.children.left.label, __indexOf.call(equivalencies.get(variable), _ref2) >= 0))) {
              termsContainingVariable.push(term);
            } else {
              termsNotContainingVariable.push(term);
            }
          } else if (term instanceof Mul) {
            added = false;
            _ref3 = term.children;
            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
              subterm = _ref3[_k];
              if (subterm instanceof terminals.Variable && (subterm.label === variable || (_ref4 = subterm.label, __indexOf.call(equivalencies.get(variable), _ref4) >= 0))) {
                termsContainingVariable.push(term);
                added = true;
                break;
              } else if (subterm instanceof Pow && subterm.children.left instanceof terminals.Variable && (subterm.children.left.label === variable || (_ref5 = subterm.children.left.label, __indexOf.call(equivalencies.get(variable), _ref5) >= 0))) {
                termsContainingVariable.push(term);
                added = true;
                break;
              }
            }
            if (!added) {
              termsNotContainingVariable.push(term);
            }
          } else if (term instanceof terminals.Variable && (term.label === variable || (_ref6 = term.label, __indexOf.call(equivalencies.get(variable), _ref6) >= 0))) {
            termsContainingVariable.push(term);
          } else {
            termsNotContainingVariable.push(term);
          }
        }
        if (termsContainingVariable.length === 0) {
          throw new AlgebraError(expr.toString(), variable);
        }
        factorised = [];
        factorisedSquares = [];
        inversed = [];
        inversedSquares = [];
        for (_l = 0, _len3 = termsContainingVariable.length; _l < _len3; _l++) {
          term = termsContainingVariable[_l];
          if (term instanceof terminals.Variable) {
            factorised.push(new terminals.Constant("1"));
          } else if (term instanceof Pow) {
            if (!(term.children.right instanceof terminals.Constant)) {
              throw new AlgebraError(expr.toString(), variable);
            }
            power = term.children.right.evaluate();
            if (term.children.left instanceof terminals.Variable && (term.children.left.label === variable || (_ref7 = term.children.left.label, __indexOf.call(equivalencies.get(variable), _ref7) >= 0))) {
              if (power === 1) {
                factorised.push(new terminals.Constant("1"));
              } else if (power === 2) {
                factorisedSquares.push(new terminals.Constant("1"));
              } else if (power === -1) {
                inversed.push(new terminals.Constant("1"));
              } else if (power === -2) {
                inversedSquares.push(new terminals.Constant("1"));
              } else {
                throw new AlgebraError(expr.toString(), variable, " (not supported)");
              }
            } else {
              throw new AlgebraError(expr.toString(), variable, " (this shouldn't happen)");
            }
          } else if (term instanceof Mul) {
            subterms = [];
            quadratic = false;
            inv = false;
            invSquare = false;
            _ref8 = term.children;
            for (_m = 0, _len4 = _ref8.length; _m < _len4; _m++) {
              subterm = _ref8[_m];
              if (subterm instanceof terminals.Variable && (subterm.label === variable || (_ref9 = subterm.label, __indexOf.call(equivalencies.get(variable), _ref9) >= 0))) {

              } else if (subterm instanceof Pow) {
                if (!(subterm.children.right instanceof terminals.Constant)) {
                  throw new AlgebraError(expr.toString(), variable);
                }
                power = subterm.children.right.evaluate();
                if (subterm.children.left instanceof terminals.Variable && (subterm.children.left.label === variable || (_ref10 = subterm.children.left.label, __indexOf.call(equivalencies.get(variable), _ref10) >= 0))) {
                  if (power === 1) {

                  } else if (power === 2) {
                    quadratic = true;
                  } else if (power === -1) {
                    inv = true;
                  } else if (power === -2) {
                    invSquare = true;
                  } else {
                    throw new AlgebraError(expr.toString(), variable, " (not supported)");
                  }
                } else {
                  subterms.push(subterm);
                }
              } else {
                subterms.push(subterm);
              }
            }
            factorisedTerm = subterms.length > 0 ? (function(func, args, ctor) {
              ctor.prototype = func.prototype;
              var child = new ctor, result = func.apply(child, args);
              return Object(result) === result ? result : child;
            })(Mul, subterms, function(){}) : new terminals.Constant("1");
            if (quadratic) {
              factorisedSquares.push(factorisedTerm);
            } else if (inv) {
              inversed.push(factorisedTerm);
            } else if (invSquare) {
              inversedSquares.push(factorisedTerm);
            } else {
              factorised.push(factorisedTerm);
            }
          }
        }
        negatedTerms = [];
        for (_n = 0, _len5 = termsNotContainingVariable.length; _n < _len5; _n++) {
          term = termsNotContainingVariable[_n];
          newMul = new Mul("-1", (term.copy != null ? term.copy() : term));
          newMul = newMul.simplify(equivalencies);
          negatedTerms.push(newMul);
        }
        if (negatedTerms.length !== 0) {
          negatedTermsEquatable = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(Add, negatedTerms, function(){});
        }
        if (termsNotContainingVariable.length !== 0) {
          nonNegatedTermsEquatable = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(Add, termsNotContainingVariable, function(){});
        }
        if (factorised.length !== 0) {
          factorisedEquatable = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(Add, factorised, function(){});
        }
        if (factorisedSquares.length !== 0) {
          factorisedSquaresEquatable = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(Add, factorisedSquares, function(){});
        }
        if (inversed.length !== 0) {
          inversedEquatable = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(Add, inversed, function(){});
        }
        if (inversedSquares.length !== 0) {
          inversedSquaresEquatable = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(Add, inversedSquares, function(){});
        }
        if (negatedTerms.length === 0) {
          negatedTermsEquatable = new terminals.Constant("0");
        }
        if (factorisedSquares.length === 0) {
          if (factorised.length === 0) {
            if (inversed.length === 0) {
              if (inversedSquares.length === 0) {
                throw new AlgebraError(expr.toString(), variable);
              } else {
                answer = new Mul(new Pow(inversedSquaresEquatable, "1/2"), new Pow(negatedTermsEquatable, "-1/2"));
                a1 = new Mul(-1, answer.copy());
                a1 = a1.expandAndSimplify(equivalencies);
                a2 = answer.expandAndSimplify(equivalencies);
                if (typeof a1.equals === "function" ? a1.equals(a2) : void 0) {
                  return [a1];
                } else {
                  return [a1, a2];
                }
              }
            } else {
              if (inversedSquares.length === 0) {
                answer = new Mul(inversedEquatable, new Pow(negatedTermsEquatable, "-1"));
                return [answer.expandAndSimplify(equivalencies)];
              } else {
                newAdd = new Add(new Mul(nonNegatedTermsEquatable, new Pow(new terminals.Variable(variable, variableUnits), 2)), new Mul(inversedEquatable, new terminals.Variable(variable, variableUnits)), inversedSquaresEquatable);
                return newAdd.solve(variable, equivalencies);
              }
            }
          } else if (inversed.length === 0) {
            if (inversedSquares.length === 0) {
              answer = new Mul(negatedTermsEquatable, new Pow(factorisedEquatable, "-1"));
              return [answer.expandAndSimplify(equivalencies)];
            } else {
              throw new AlgebraError(expr.toString(), variable, " (not supported)");
            }
          } else {
            throw new AlgebraError(expr.toString(), variable, " (not supported)");
          }
        } else if (factorised.length === 0) {
          if (inversed.length === 0) {
            if (inversedSquares.length === 0) {
              answer = new Pow(new Mul(negatedTermsEquatable, new Pow(factorisedSquaresEquatable, "-1")), "1/2");
              a1 = new Mul("-1", answer.copy());
              a1 = a1.expandAndSimplify(equivalencies);
              a2 = answer.expandAndSimplify(equivalencies);
              if (typeof a1.equals === "function" ? a1.equals(a2) : void 0) {
                return [a1];
              } else {
                return [a1, a2];
              }
            } else {
              throw new AlgebraError(expr.toString(), variable, " (not supported)");
            }
          } else {
            throw new AlgebraError(expr.toString(), variable, " (not supported)");
          }
        } else {
          if (inversed.length > 0 || inversedSquares.length > 0) {
            throw new AlgebraError(expr.toString(), variable, " (not supported)");
          }
          if (nonNegatedTermsEquatable != null) {
            a = factorisedSquaresEquatable;
            b = factorisedEquatable;
            c = nonNegatedTermsEquatable;
            d = new Add(new Pow(b, "2"), new Mul("-4", a, c));
            rd = new Pow(d, "1/2");
            v1 = new Mul(new Add(new Mul("-1", b), rd), new Pow(new Mul("2", a), "-1"));
            v2 = new Mul("-1", new Add(b, rd), new Pow(new Mul("2", a), "-1"));
            v1 = v1.expandAndSimplify(equivalencies);
            v2 = v2.expandAndSimplify(equivalencies);
            if ((v1.equals != null) && v1.equals(v2)) {
              return [v1];
            }
            return [v1, v2];
          } else {
            newPow = new Pow(factorisedSquaresEquatable, "-1");
            newMul = new Mul("-1", factorisedEquatable, newPow);
            newMul = newMul.simplify(equivalencies);
            return [0, newMul];
          }
        }
      };

      Add.prototype.getAllVariables = function() {
        var child, childVariables, outVariables, variable, variables, _i, _j, _len, _len1, _ref;
        variables = {};
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child instanceof terminals.Variable) {
            variables[child.label] = true;
          } else if (child.getAllVariables != null) {
            childVariables = child.getAllVariables();
            for (_j = 0, _len1 = childVariables.length; _j < _len1; _j++) {
              variable = childVariables[_j];
              variables[variable] = true;
            }
          }
        }
        outVariables = [];
        for (variable in variables) {
          outVariables.push(variable);
        }
        return outVariables;
      };

      Add.prototype.replaceVariables = function(replacements) {
        var child, children, index, _i, _len, _ref;
        children = [];
        _ref = this.children;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          child = _ref[index];
          if (child instanceof terminals.Variable && child.label in replacements) {
            children.push(child.copy());
            children[index].label = replacements[child.label];
          } else if (child.replaceVariables != null) {
            children.push(child.replaceVariables(replacements));
          } else {
            children.push(child.copy());
          }
        }
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Add, children, function(){});
      };

      Add.prototype.sub = function(substitutions, uncertaintySubstitutions, equivalencies, assumeZeroUncertainty, evaluateSymbolicConstants) {
        var child, children, equiv, newAdd, subbed, variable, variableEquivalencies, _i, _j, _len, _len1, _ref;
        if (equivalencies == null) {
          equivalencies = null;
        }
        if (assumeZeroUncertainty == null) {
          assumeZeroUncertainty = false;
        }
        if (evaluateSymbolicConstants == null) {
          evaluateSymbolicConstants = false;
        }
        for (variable in substitutions) {
          if (substitutions[variable].copy == null) {
            substitutions[variable] = new terminals.Constant(substitutions[variable]);
          }
        }
        if (equivalencies == null) {
          equivalencies = {
            get: function(z) {
              return [z];
            }
          };
        }
        children = [];
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child instanceof terminals.Variable) {
            variableEquivalencies = equivalencies.get(child.label);
            subbed = false;
            for (_j = 0, _len1 = variableEquivalencies.length; _j < _len1; _j++) {
              equiv = variableEquivalencies[_j];
              if (equiv in substitutions) {
                children.push(substitutions[equiv].copy());
                subbed = true;
                break;
              }
            }
            if (!subbed) {
              children.push(child.copy());
            }
          } else if (child.sub != null) {
            children.push(child.sub(substitutions, uncertaintySubstitutions, equivalencies, assumeZeroUncertainty, evaluateSymbolicConstants));
          } else {
            children.push(child.copy());
          }
        }
        newAdd = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Add, children, function(){});
        newAdd = newAdd.expandAndSimplify(equivalencies);
        return newAdd;
      };

      Add.prototype.substituteExpression = function(sourceExpression, variable, equivalencies, eliminate) {
        var child, children, childrenArray, childrenExpressions, expression, newAdd, results, sourceExpressions, variableEquivalencies, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
        if (equivalencies == null) {
          equivalencies = null;
        }
        if (eliminate == null) {
          eliminate = false;
        }
        if (eliminate) {
          sourceExpressions = sourceExpression.solve(variable, equivalencies);
        } else {
          sourceExpressions = [sourceExpression];
        }
        if (equivalencies == null) {
          equivalencies = {
            get: function(variable) {
              return [variable];
            }
          };
        }
        variableEquivalencies = equivalencies.get(variable);
        results = [];
        for (_i = 0, _len = sourceExpressions.length; _i < _len; _i++) {
          expression = sourceExpressions[_i];
          childrenExpressions = [];
          _ref = this.children;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            child = _ref[_j];
            if (child instanceof terminals.Variable && (child.label === variable || (_ref1 = child.label, __indexOf.call(variableEquivalencies, _ref1) >= 0))) {
              childrenExpressions.push([expression.copy()]);
            } else if (child.substituteExpression != null) {
              childrenExpressions.push(child.substituteExpression(expression, variable, equivalencies));
            } else {
              childrenExpressions.push([child.copy()]);
            }
          }
          childrenArray = combinations(childrenExpressions);
        }
        for (_k = 0, _len2 = childrenArray.length; _k < _len2; _k++) {
          children = childrenArray[_k];
          newAdd = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(Add, children, function(){});
          results.push(newAdd.expandAndSimplify(equivalencies));
        }
        return results;
      };

      Add.prototype.toDrawingNode = function() {
        var AddNode;
        AddNode = prettyRender.Add;
        return AddNode.makeWithBrackets.apply(AddNode, this.children.map(function(term) {
          return term.toDrawingNode();
        }));
      };

      Add.prototype.differentiate = function(variable) {
        var derivative, newChildren;
        newChildren = this.children.map(function(x) {
          return x.differentiate(variable);
        });
        derivative = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Add, newChildren, function(){});
        return derivative.expandAndSimplify();
      };

      return Add;

    })(nodes.RoseNode);
    return Add;
  });

}).call(this);
