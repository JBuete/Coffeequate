// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(["nodes", "terminals", "AlgebraError", "parseArgs", "require", "compare", "prettyRender"], function(nodes, terminals, AlgebraError, parseArgs, require, compare, prettyRender) {
    var Pow;
    return Pow = (function(_super) {
      __extends(Pow, _super);

      function Pow() {
        var args, base, power, _ref;
        base = arguments[0], power = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        if (!((base != null) && (power != null))) {
          throw new Error("Pow nodes must have two children.");
        }
        if (args.length > 0) {
          throw new Error("Pow nodes must have two children.");
        }
        this.cmp = -3;
        _ref = parseArgs(base, power), base = _ref[0], power = _ref[1];
        Pow.__super__.constructor.call(this, "**", base, power);
      }

      Pow.prototype.copy = function() {
        return new Pow((this.children.left.copy != null ? this.children.left.copy() : this.children.left), (this.children.right.copy != null ? this.children.right.copy() : this.children.right));
      };

      Pow.prototype.sort = function() {
        var _base, _base1;
        if (typeof (_base = this.children.left).sort === "function") {
          _base.sort();
        }
        return typeof (_base1 = this.children.right).sort === "function" ? _base1.sort() : void 0;
      };

      Pow.prototype.equals = function(b, equivalencies) {
        if (!(b instanceof Pow)) {
          return false;
        }
        if (this.children.left.equals != null) {
          if (!this.children.left.equals(b.children.left, equivalencies)) {
            return false;
          }
        } else {
          if (this.children.left !== b.children.left) {
            return false;
          }
        }
        if (this.children.right.equals != null) {
          if (!this.children.right.equals(b.children.right, equivalencies)) {
            return false;
          }
        } else {
          if (this.children.right !== b.children.right) {
            return false;
          }
        }
        return true;
      };

      Pow.prototype.compareSameType = function(b) {
        var c;
        c = compare(this.children.left, b.children.left);
        if (c !== 0) {
          return c;
        } else {
          return compare(this.children.right, b.children.right);
        }
      };

      Pow.prototype.getVariableUnits = function(variable, equivalencies) {
        var leftVariableUnits, rightVariableUnits, variableEquivalencies, _ref, _ref1;
        variableEquivalencies = equivalencies != null ? equivalencies.get(variable) : {
          get: function(z) {
            return [z];
          }
        };
        if (this.children.left instanceof terminals.Variable && (_ref = this.children.left.label, __indexOf.call(variableEquivalencies, _ref) >= 0)) {
          return this.children.left.units;
        } else {
          leftVariableUnits = this.children.left.getVariableUnits(variable, equivalencies);
          if (leftVariableUnits != null) {
            return leftVariableUnits;
          }
        }
        if (this.children.right instanceof terminals.Variable && (_ref1 = this.children.right.label, __indexOf.call(variableEquivalencies, _ref1) >= 0)) {
          return this.children.right.units;
        } else {
          rightVariableUnits = this.children.right.getVariableUnits(variable, equivalencies);
          if (rightVariableUnits != null) {
            return rightVariableUnits;
          }
        }
        return null;
      };

      Pow.prototype.setVariableUnits = function(variable, equivalencies, units) {
        var variableEquivalencies;
        variableEquivalencies = equivalencies != null ? equivalencies.get(variable) : {
          get: function(z) {
            return [z];
          }
        };
        this.children.left.setVariableUnits(variable, equivalencies, units);
        return this.children.right.setVariableUnits(variable, equivalencies, units);
      };

      Pow.prototype.expand = function() {
        var Add, Mul, child, children, i, index, left, newMul, newPow, right, _i, _j, _len, _ref, _ref1;
        Mul = require("operators/Mul");
        Add = require("operators/Add");
        if (this.children.left.expand != null) {
          left = this.children.left.expand();
        } else if (this.children.left.copy != null) {
          left = this.children.left.copy();
        } else {
          left = this.children.left;
        }
        if (this.children.right.expand != null) {
          right = this.children.right.expand();
        } else if (this.children.right.copy != null) {
          right = this.children.right.copy();
        } else {
          right = this.children.right;
        }
        if (left.children != null) {
          if (left instanceof Pow) {
            left.children.right = new Mul(left.children.right, right);
            left.expand();
          } else if (left instanceof Mul) {
            _ref = left.children;
            for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
              child = _ref[index];
              newPow = new Pow(child, right);
              newPow = newPow.expand();
              left.children[index] = newPow;
            }
          } else if (left instanceof Add) {
            if (right instanceof terminals.Constant && right.evaluate() % 1 === 0 && right.evaluate() > 0) {
              children = [];
              for (i = _j = 1, _ref1 = right.evaluate(); 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
                children.push(left);
              }
              newMul = (function(func, args, ctor) {
                ctor.prototype = func.prototype;
                var child = new ctor, result = func.apply(child, args);
                return Object(result) === result ? result : child;
              })(Mul, children, function(){});
              newMul = newMul.expand();
              left = newMul;
            } else {
              left = new Pow(left, right);
            }
          }
          return left;
        } else {
          return new Pow(left, right);
        }
      };

      Pow.prototype.simplify = function(equivalencies) {
        var Mul, left, newPow, power, right;
        Mul = require("operators/Mul");
        if (equivalencies == null) {
          equivalencies = {
            get: function(variable) {
              return [variable];
            }
          };
        }
        if (this.children.left.simplify != null) {
          left = this.children.left.simplify(equivalencies);
        } else if (this.children.left.copy != null) {
          left = this.children.left.copy();
        } else {
          left = this.children.left;
        }
        if (this.children.right.simplify != null) {
          right = this.children.right.simplify(equivalencies);
        } else if (this.children.right.copy != null) {
          right = this.children.right.copy();
        } else {
          right = this.children.right;
        }
        if ((typeof right.evaluate === "function" ? right.evaluate() : void 0) === 1) {
          return left;
        } else if ((typeof left.evaluate === "function" ? left.evaluate() : void 0) === 1) {
          return left;
        } else if ((typeof right.evaluate === "function" ? right.evaluate() : void 0) === 0) {
          return new terminals.Constant("1");
        } else {
          if (right instanceof terminals.Constant && left instanceof terminals.Constant) {
            return left.pow(right);
          } else if (left instanceof Pow) {
            power = new Mul(left.children.right, right);
            newPow = new Pow(left.children.left, power);
            newPow = newPow.simplify(equivalencies);
            return newPow;
          } else {
            return new Pow(left, right);
          }
        }
      };

      Pow.prototype.expandAndSimplify = function(equivalencies) {
        var expr;
        expr = this.expand();
        if (expr.simplify != null) {
          return expr.simplify(equivalencies);
        }
        return expr;
      };

      Pow.prototype.solve = function(variable, equivalencies) {
        var Mul, error, expr, negative, returnables, solution, solutions, _i, _len, _ref, _ref1;
        Mul = require("operators/Mul");
        if (equivalencies == null) {
          equivalencies = {
            get: function(variable) {
              return [variable];
            }
          };
        }
        expr = this.expandAndSimplify(equivalencies);
        if (expr instanceof terminals.Terminal) {
          if (expr instanceof terminals.Variable && (expr.label === variable || (_ref = expr.label, __indexOf.call(equivalencies.get(variable), _ref) >= 0))) {
            return [new terminals.Constant("0")];
          } else {
            throw new AlgebraError(expr.toString(), variable);
          }
        }
        if (expr instanceof Pow) {
          if (expr.children.left instanceof terminals.Variable) {
            if (expr.children.left.label === variable || (_ref1 = expr.children.left.label, __indexOf.call(equivalencies.get(variable), _ref1) >= 0)) {
              return [new terminals.Constant("0")];
            }
            throw new AlgebraError(expr.toString(), variable);
          } else if (expr.children.left instanceof terminals.Terminal) {
            throw new AlgebraError(expr.toString(), variable);
          } else {
            try {
              solutions = expr.children.left.solve(variable, equivalencies);
            } catch (_error) {
              error = _error;
              throw error;
            }
            if ((expr.children.right.evaluate != null) && expr.children.right.evaluate() % 2 === 0) {
              returnables = [];
              for (_i = 0, _len = solutions.length; _i < _len; _i++) {
                solution = solutions[_i];
                negative = (new Mul(-1, solution)).simplify(equivalencies);
                if (negative.equals != null) {
                  if (!negative.equals(solution)) {
                    returnables.push(negative);
                  }
                  returnables.push(solution);
                } else {
                  if (negative !== solution) {
                    returnables.push(negative);
                  }
                  returnables.push(solution);
                }
              }
              return returnables;
            } else {
              return solutions;
            }
          }
        } else {
          return expr.solve(variable, equivalencies);
        }
      };

      Pow.prototype.sub = function(substitutions, uncertaintySubstitutions, equivalencies, assumeZeroUncertainty, evaluateSymbolicConstants) {
        var equiv, left, newPow, right, subbed, variable, variableEquivalencies, _i, _j, _len, _len1;
        if (equivalencies == null) {
          equivalencies = null;
        }
        if (assumeZeroUncertainty == null) {
          assumeZeroUncertainty = false;
        }
        if (evaluateSymbolicConstants == null) {
          evaluateSymbolicConstants = false;
        }
        for (variable in substitutions) {
          if (substitutions[variable].copy == null) {
            substitutions[variable] = new terminals.Constant(substitutions[variable]);
          }
        }
        if (equivalencies == null) {
          equivalencies = {
            get: function(z) {
              return [z];
            }
          };
        }
        left = null;
        right = null;
        if (this.children.left instanceof terminals.Variable) {
          variableEquivalencies = equivalencies.get(this.children.left.label);
          subbed = false;
          for (_i = 0, _len = variableEquivalencies.length; _i < _len; _i++) {
            equiv = variableEquivalencies[_i];
            if (equiv in substitutions) {
              left = substitutions[equiv].copy();
              subbed = true;
              break;
            }
          }
          if (!subbed) {
            left = this.children.left.copy();
          }
        } else if (this.children.left.sub != null) {
          left = this.children.left.sub(substitutions, uncertaintySubstitutions, equivalencies, assumeZeroUncertainty, evaluateSymbolicConstants);
        } else {
          left = this.children.left.copy();
        }
        if (this.children.right instanceof terminals.Variable) {
          variableEquivalencies = equivalencies.get(this.children.right.label);
          subbed = false;
          for (_j = 0, _len1 = variableEquivalencies.length; _j < _len1; _j++) {
            equiv = variableEquivalencies[_j];
            if (equiv in substitutions) {
              right = substitutions[equiv].copy();
              subbed = true;
              break;
            }
          }
          if (!subbed) {
            right = this.children.right.copy();
          }
        } else if (this.children.right.sub != null) {
          right = this.children.right.sub(substitutions, uncertaintySubstitutions, equivalencies, assumeZeroUncertainty, evaluateSymbolicConstants);
        } else {
          right = this.children.right.copy();
        }
        newPow = new Pow(left, right);
        newPow = newPow.expandAndSimplify(equivalencies);
        return newPow;
      };

      Pow.prototype.getAllVariables = function() {
        var leftVariables, outVariables, rightVariables, variable, variables, _i, _j, _len, _len1;
        variables = {};
        if (this.children.left instanceof terminals.Variable) {
          variables[this.children.left.label] = true;
        } else if (this.children.left.getAllVariables != null) {
          leftVariables = this.children.left.getAllVariables();
          for (_i = 0, _len = leftVariables.length; _i < _len; _i++) {
            variable = leftVariables[_i];
            variables[variable] = true;
          }
        }
        if (this.children.right instanceof terminals.Variable) {
          variables[this.children.right.label] = true;
        } else if (this.children.right.getAllVariables != null) {
          rightVariables = this.children.right.getAllVariables();
          for (_j = 0, _len1 = rightVariables.length; _j < _len1; _j++) {
            variable = rightVariables[_j];
            variables[variable] = true;
          }
        }
        outVariables = [];
        for (variable in variables) {
          outVariables.push(variable);
        }
        return outVariables;
      };

      Pow.prototype.replaceVariables = function(replacements) {
        var left, right;
        left = this.children.left.copy();
        right = this.children.right.copy();
        if (left instanceof terminals.Variable && left.label in replacements) {
          left.label = replacements[left.label];
        } else if (left.replaceVariables != null) {
          left = left.replaceVariables(replacements);
        }
        if (right instanceof terminals.Variable && right.label in replacements) {
          right.label = replacements[right.label];
        } else if (right.replaceVariables != null) {
          right = right.replaceVariables(replacements);
        }
        return new Pow(left, right);
      };

      Pow.prototype.substituteExpression = function(sourceExpression, variable, equivalencies, eliminate) {
        var expression, i, j, left, newPow, results, right, sourceExpressions, variableEquivalencies, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
        if (equivalencies == null) {
          equivalencies = null;
        }
        if (eliminate == null) {
          eliminate = false;
        }
        if (eliminate) {
          sourceExpressions = sourceExpression.solve(variable, equivalencies);
        } else {
          sourceExpressions = [sourceExpression];
        }
        if (equivalencies == null) {
          equivalencies = {
            get: function(variable) {
              return [variable];
            }
          };
        }
        variableEquivalencies = equivalencies.get(variable);
        results = [];
        for (_i = 0, _len = sourceExpressions.length; _i < _len; _i++) {
          expression = sourceExpressions[_i];
          left = [this.children.left.copy()];
          right = [this.children.right.copy()];
          if (this.children.left instanceof terminals.Variable && (this.children.left.label === variable || (_ref = this.children.left.label, __indexOf.call(variableEquivalencies, _ref) >= 0))) {
            left = [expression.copy()];
          } else if (!(this.children.left instanceof terminals.Terminal)) {
            left = this.children.left.substituteExpression(expression, variable, equivalencies);
          }
          if (this.children.right instanceof terminals.Variable && (this.children.right.label === variable || (_ref1 = this.children.right.label, __indexOf.call(variableEquivalencies, _ref1) >= 0))) {
            right = [expression.copy()];
          } else if (!(this.children.right instanceof terminals.Terminal)) {
            right = this.children.right.substituteExpression(expression, variable, equivalencies);
          }
          for (_j = 0, _len1 = left.length; _j < _len1; _j++) {
            i = left[_j];
            for (_k = 0, _len2 = right.length; _k < _len2; _k++) {
              j = right[_k];
              newPow = new Pow(i, j);
              newPow = newPow.expandAndSimplify(equivalencies);
              results.push(newPow);
            }
          }
        }
        return results;
      };

      Pow.prototype.toDrawingNode = function() {
        var FractionNode, NumberNode, PowNode, SurdNode;
        SurdNode = prettyRender != null ? prettyRender.Surd : void 0;
        PowNode = prettyRender.Pow;
        FractionNode = prettyRender.Fraction;
        NumberNode = prettyRender.Number;
        if (this.children.right instanceof terminals.Constant) {
          if (this.children.right.numerator === 1) {
            if (this.children.right.denominator === 1) {
              return this.children.left.toDrawingNode();
            }
            if (this.children.right.denominator > 0) {
              return new SurdNode(this.children.left.toDrawingNode(), this.children.right.denominator);
            } else {
              return new FractionNode(new NumberNode(1), new SurdNode(this.children.left.toDrawingNode(), -this.children.right.denominator));
            }
          }
        }
        return new PowNode(PowNode.prototype.bracketIfNeeded(this.children.left.toDrawingNode()), this.children.right.toDrawingNode());
      };

      Pow.prototype.differentiate = function(variable) {
        var Add, Constant, Mul, _base;
        Add = require("operators/Add");
        Mul = require("operators/Mul");
        Constant = require("terminals").Constant;
        if (__indexOf.call(this.children.right.getAllVariables, variable) >= 0) {
          throw new Error("I can't differentiate with a variable on the top of a power");
        }
        if ((typeof (_base = this.children.right).evaluate === "function" ? _base.evaluate() : void 0) === 0) {
          return new Constant(0);
        }
        return new Mul(new Pow(this.children.left, new Add(this.children.right, new Constant(-1))), this.children.left.differentiate(variable), this.children.right).expandAndSimplify();
      };

      return Pow;

    })(nodes.BinaryNode);
  });

}).call(this);
