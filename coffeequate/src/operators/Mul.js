// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(["nodes", "terminals", "AlgebraError", "parseArgs", "require", "compare", "prettyRender"], function(nodes, terminals, AlgebraError, parseArgs, require, compare, prettyRender) {
    var Mul, combinations;
    combinations = function(list) {
      var i, ii, results, _i, _j, _len, _len1, _ref, _ref1;
      if (list.length === 1) {
        return (function() {
          var _i, _len, _ref, _results;
          _ref = list[0];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            i = _ref[_i];
            _results.push(i);
          }
          return _results;
        })();
      } else {
        results = [];
        _ref = list[0];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          _ref1 = combinations(list.slice(1));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            ii = _ref1[_j];
            results.push([i].concat(ii));
          }
        }
        return results;
      }
    };
    Mul = (function(_super) {
      __extends(Mul, _super);

      function Mul() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (args.length < 1) {
          throw new Error("Mul nodes must have at least one child.");
        }
        this.cmp = -2;
        args = parseArgs.apply(null, args);
        Mul.__super__.constructor.call(this, "*", args);
      }

      Mul.prototype.copy = function() {
        var args, i;
        args = (function() {
          var _i, _len, _ref, _results;
          _ref = this.children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            i = _ref[_i];
            _results.push(i.copy != null ? i.copy() : i);
          }
          return _results;
        }).call(this);
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Mul, args, function(){});
      };

      Mul.prototype.simplifyConstants = function() {
        var child, constantterm, variableterm, _i, _len, _ref;
        constantterm = new terminals.Constant("1");
        variableterm = null;
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child instanceof terminals.Constant) {
            constantterm = constantterm.mul(child);
          } else {
            if (variableterm != null) {
              variableterm.children.push(child);
            } else {
              variableterm = new Mul(child);
            }
          }
        }
        if (variableterm == null) {
          return constantterm;
        }
        if (constantterm.evaluate() === 1) {
          return variableterm;
        }
        return new Mul(constantterm, variableterm);
      };

      Mul.prototype.compareSameType = function(b) {
        var c, child, index, lengthComparison, _i, _len, _ref;
        if (this.children.length === b.children.length) {
          lengthComparison = 0;
        } else if (this.children.length < b.children.length) {
          lengthComparison = -1;
        } else {
          lengthComparison = 1;
        }
        _ref = this.children;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          child = _ref[index];
          if (b.children[index] == null) {
            return 1;
          }
          c = compare(this.children[index], b.children[index]);
          if (c !== 0) {
            return c;
          }
        }
        return lengthComparison;
      };

      Mul.prototype.getVariableUnits = function(variable, equivalencies) {
        var child, childVariableUnits, variableEquivalencies, _i, _len, _ref, _ref1;
        variableEquivalencies = equivalencies != null ? equivalencies.get(variable) : [variable];
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child instanceof terminals.Variable && (_ref1 = child.label, __indexOf.call(variableEquivalencies, _ref1) >= 0)) {
            return child.units;
          } else {
            childVariableUnits = child.getVariableUnits(variable, equivalencies);
            if (childVariableUnits != null) {
              return childVariableUnits;
            }
          }
        }
        return null;
      };

      Mul.prototype.setVariableUnits = function(variable, equivalencies, units) {
        var child, variableEquivalencies, _i, _len, _ref, _results;
        variableEquivalencies = equivalencies != null ? equivalencies.get(variable) : {
          get: function(z) {
            return [z];
          }
        };
        _ref = this.children;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          _results.push(child.setVariableUnits(variable, equivalencies, units));
        }
        return _results;
      };

      Mul.expandMulAdd = function(mul, add) {
        var Add, c, child, newAdd, newMul, results, _i, _j, _len, _len1, _ref, _ref1;
        Add = require("operators/Add");
        results = [];
        _ref = add.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.copy != null) {
            child = child.copy();
          }
          if (child instanceof Mul) {
            newMul = mul.copy();
            _ref1 = child.children;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              c = _ref1[_j];
              newMul.children.push(c);
            }
          } else if (child instanceof Add) {
            newMul = Mul.expandMulAdd(mul, child);
          } else {
            if (mul.children.length === 1) {
              newMul = mul.copy();
              newMul.children.push(child.copy());
            } else {
              newMul = new Mul(mul.copy(), child.copy());
            }
          }
          results.push(newMul);
        }
        newAdd = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Add, results, function(){});
        newAdd = newAdd.expand();
        return newAdd;
      };

      Mul.prototype.equals = function(b, equivalencies) {
        var child, index, _i, _len, _ref;
        if (!(b instanceof Mul)) {
          return false;
        }
        if (b.children.length !== this.children.length) {
          return false;
        }
        _ref = this.children;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          child = _ref[index];
          if (child.equals != null) {
            if (!child.equals(b.children[index], equivalencies)) {
              return false;
            }
          } else {
            if (child !== b.children[index]) {
              return false;
            }
          }
        }
        return true;
      };

      Mul.prototype.expand = function() {
        var Add, child, newMul, results, term, _base, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
        Add = require("operators/Add");
        term = [];
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.expand != null) {
            child = child.expand();
          } else if (child.copy != null) {
            child = child.copy();
          }
          term.push(child);
        }
        while (term.length > 1) {
          if (term[0] instanceof Mul) {
            if (term[1] instanceof Add) {
              term[0] = Mul.expandMulAdd(term[0], term.splice(1, 1)[0]);
            } else if (term[1] instanceof Mul) {
              _ref1 = term.splice(1, 1)[0].children;
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                child = _ref1[_j];
                term[0].children.push(child);
              }
            } else {
              term[0].children.push(term.splice(1, 1)[0]);
            }
          } else if (term[0] instanceof Add) {
            if (term[1] instanceof Add) {
              results = [];
              _ref2 = term[0].children;
              for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                child = _ref2[_k];
                newMul = new Mul(child, term[1]);
                newMul = newMul.expand();
                results.push(newMul);
              }
              term.splice(1, 1);
              term[0] = (function(func, args, ctor) {
                ctor.prototype = func.prototype;
                var child = new ctor, result = func.apply(child, args);
                return Object(result) === result ? result : child;
              })(Add, results, function(){});
              term[0] = term[0].expand();
            } else if (term[1] instanceof Mul) {
              term[0] = Mul.expandMulAdd(term.splice(1, 1)[0], term[0]);
            } else {
              term[0] = new Mul(term[0], term.splice(1, 1)[0]);
            }
          } else {
            term[0] = new Mul(term[0]);
          }
        }
        if (typeof (_base = term[0]).sort === "function") {
          _base.sort();
        }
        return term[0];
      };

      Mul.prototype.simplify = function(equivalencies) {
        var Add, Pow, base, c, child, constantterm, found, i, index, liketerm, liketerms, newMul, newPow, numerical, power, term, terms, _base, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
        Add = require("operators/Add");
        Pow = require("operators/Pow");
        if (equivalencies == null) {
          equivalencies = {
            get: function(variable) {
              return [variable];
            }
          };
        }
        terms = [];
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.simplify != null) {
            child = child.simplify(equivalencies);
          } else if (child.copy != null) {
            child = child.copy();
          }
          terms.push(child);
        }
        liketerms = [];
        constantterm = null;
        i = 0;
        while (i < terms.length) {
          term = terms[i];
          if (term instanceof Mul) {
            child = terms.splice(i, 1)[0];
            _ref1 = child.children;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              c = _ref1[_j];
              terms.push(c);
            }
            i -= 1;
          } else if (term instanceof terminals.Constant) {
            if (constantterm != null) {
              constantterm = constantterm.mul(term);
            } else {
              constantterm = term.copy();
            }
          } else if (term instanceof Pow) {
            base = term.children.left;
            power = term.children.right;
            found = false;
            for (index = _k = 0, _len2 = liketerms.length; _k < _len2; index = ++_k) {
              liketerm = liketerms[index];
              if (liketerm[0].equals != null) {
                if (liketerm[0].equals(base, equivalencies)) {
                  liketerms[index][1] = new Add(liketerm[1], power);
                  liketerms[index][1] = liketerms[index][1].simplify(equivalencies);
                  if (((_ref2 = liketerms[index][1].children) != null ? _ref2.length : void 0) === 1) {
                    liketerms[index][1] = liketerms[index][1].children[0];
                  }
                  found = true;
                }
              } else if (liketerm[0] === base) {
                liketerms[index][1] = new Add(liketerm[1], power);
                liketerms[index][1] = liketerms[index][1].simplify(equivalencies);
                if (((_ref3 = liketerms[index][1].children) != null ? _ref3.length : void 0) === 1) {
                  liketerms[index][1] = liketerms[index][1].children[0];
                }
                found = true;
              }
            }
            if (!found) {
              liketerms.push([base, power]);
            }
          } else {
            found = false;
            for (index = _l = 0, _len3 = liketerms.length; _l < _len3; index = ++_l) {
              liketerm = liketerms[index];
              if (liketerm[0].equals != null) {
                if (liketerm[0].equals(term, equivalencies)) {
                  liketerms[index][1] = new Add(liketerm[1], new terminals.Constant("1"));
                  liketerms[index][1] = liketerms[index][1].simplify(equivalencies);
                  if (((_ref4 = liketerms[index][1].children) != null ? _ref4.length : void 0) === 1) {
                    liketerms[index][1] = liketerms[index][1].children[0];
                  }
                  found = true;
                }
              } else if (liketerm[0] === term) {
                liketerms[index][1] = new Add(liketerm[1], new terminals.Constant("1"));
                liketerms[index][1] = liketerms[index][1].simplify(equivalencies);
                if (((_ref5 = liketerms[index][1].children) != null ? _ref5.length : void 0) === 1) {
                  liketerms[index][1] = liketerms[index][1].children[0];
                }
                found = true;
              }
            }
            if (!found) {
              liketerms.push([term, new terminals.Constant("1")]);
            }
          }
          i += 1;
        }
        if ((constantterm != null ? typeof constantterm.evaluate === "function" ? constantterm.evaluate() : void 0 : void 0) === 0) {
          return new terminals.Constant("0");
        }
        newMul = null;
        for (_m = 0, _len4 = liketerms.length; _m < _len4; _m++) {
          liketerm = liketerms[_m];
          if ((typeof (_base = liketerm[1]).evaluate === "function" ? _base.evaluate() : void 0) !== 1) {
            newPow = new Pow(liketerm[0], liketerm[1]);
            newPow = newPow.simplify(equivalencies);
          } else {
            newPow = liketerm[0];
          }
          if (newMul != null) {
            newMul.children.push(newPow);
          } else {
            newMul = new Mul(newPow);
          }
        }
        if (newMul == null) {
          return constantterm;
        }
        if ((constantterm != null) && constantterm.evaluate() !== 1) {
          newMul.children.push(constantterm);
        }
        newMul.sort();
        numerical = true;
        _ref6 = newMul.children;
        for (_n = 0, _len5 = _ref6.length; _n < _len5; _n++) {
          child = _ref6[_n];
          if (!(child instanceof terminals.Constant)) {
            numerical = false;
            break;
          }
        }
        if (numerical) {
          return newMul.simplifyConstants();
        }
        if (newMul.children.length !== 1) {
          return newMul;
        }
        return newMul.children[0];
      };

      Mul.prototype.sort = function() {
        var child, _i, _len, _ref;
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (typeof child.sort === "function") {
            child.sort();
          }
        }
        return this.children.sort(compare);
      };

      Mul.prototype.expandAndSimplify = function(equivalencies) {
        var expr;
        expr = this.expand();
        if (expr.simplify != null) {
          return expr.simplify(equivalencies);
        }
        return expr;
      };

      Mul.prototype.solve = function(variable, equivalencies) {
        var Pow, child, error, expr, _i, _len, _ref, _ref1, _ref2;
        if (equivalencies == null) {
          equivalencies = null;
        }
        Pow = require("operators/Pow");
        expr = this.expandAndSimplify(equivalencies);
        if (equivalencies == null) {
          equivalencies = {
            get: function(variable) {
              return [variable];
            }
          };
        }
        if (expr instanceof terminals.Terminal) {
          if (expr instanceof terminals.Variable && (expr.label === variable || (_ref = expr.label, __indexOf.call(equivalencies.get(variable), _ref) >= 0))) {
            return [new terminals.Constant("0")];
          } else {
            throw new AlgebraError(expr.toString(), variable);
          }
        }
        if (!(expr instanceof Mul)) {
          return expr.solve(variable, equivalencies);
        }
        _ref1 = expr.children;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          child = _ref1[_i];
          if (child instanceof terminals.Variable && (child.label === variable || (_ref2 = child.label, __indexOf.call(equivalencies.get(variable), _ref2) >= 0))) {
            return [new terminals.Constant("0")];
          } else if (child instanceof Pow) {
            try {
              return child.solve(variable, equivalencies);
            } catch (_error) {
              error = _error;
              if (error instanceof AlgebraError) {
                continue;
              } else {
                throw error;
              }
            }
          }
        }
        throw new AlgebraError(expr.toString(), variable);
      };

      Mul.prototype.getAllVariables = function() {
        var child, childVariables, outVariables, variable, variables, _i, _j, _len, _len1, _ref;
        variables = {};
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child instanceof terminals.Variable) {
            variables[child.label] = true;
          } else if (child.getAllVariables != null) {
            childVariables = child.getAllVariables();
            for (_j = 0, _len1 = childVariables.length; _j < _len1; _j++) {
              variable = childVariables[_j];
              variables[variable] = true;
            }
          }
        }
        outVariables = [];
        for (variable in variables) {
          outVariables.push(variable);
        }
        return outVariables;
      };

      Mul.prototype.replaceVariables = function(replacements) {
        var child, children, index, _i, _len, _ref;
        children = [];
        _ref = this.children;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          child = _ref[index];
          if (child instanceof terminals.Variable && child.label in replacements) {
            children.push(child.copy());
            children[index].label = replacements[child.label];
          } else if (child.replaceVariables != null) {
            children.push(child.replaceVariables(replacements));
          } else {
            children.push(child.copy());
          }
        }
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Mul, children, function(){});
      };

      Mul.prototype.sub = function(substitutions, uncertaintySubstitutions, equivalencies, assumeZeroUncertainty, evaluateSymbolicConstants) {
        var child, children, equiv, newMul, subbed, variable, variableEquivalencies, _i, _j, _len, _len1, _ref;
        if (equivalencies == null) {
          equivalencies = null;
        }
        if (assumeZeroUncertainty == null) {
          assumeZeroUncertainty = false;
        }
        if (evaluateSymbolicConstants == null) {
          evaluateSymbolicConstants = false;
        }
        for (variable in substitutions) {
          if (substitutions[variable].copy == null) {
            substitutions[variable] = new terminals.Constant(substitutions[variable]);
          }
        }
        if (equivalencies == null) {
          equivalencies = {
            get: function(z) {
              return [z];
            }
          };
        }
        children = [];
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child instanceof terminals.Variable) {
            variableEquivalencies = equivalencies.get(child.label);
            subbed = false;
            for (_j = 0, _len1 = variableEquivalencies.length; _j < _len1; _j++) {
              equiv = variableEquivalencies[_j];
              if (equiv in substitutions) {
                children.push(substitutions[equiv].copy());
                subbed = true;
                break;
              }
            }
            if (!subbed) {
              children.push(child.copy());
            }
          } else if (child.sub != null) {
            children.push(child.sub(substitutions, uncertaintySubstitutions, equivalencies, assumeZeroUncertainty, evaluateSymbolicConstants));
          } else {
            children.push(child.copy());
          }
        }
        newMul = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Mul, children, function(){});
        newMul = newMul.expandAndSimplify(equivalencies);
        return newMul;
      };

      Mul.prototype.substituteExpression = function(sourceExpression, variable, equivalencies, eliminate) {
        var child, children, childrenArray, childrenExpressions, expression, newMul, results, sourceExpressions, variableEquivalencies, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
        if (equivalencies == null) {
          equivalencies = null;
        }
        if (eliminate == null) {
          eliminate = false;
        }
        if (eliminate) {
          sourceExpressions = sourceExpression.solve(variable, equivalencies);
        } else {
          sourceExpressions = [sourceExpression];
        }
        if (equivalencies == null) {
          equivalencies = {
            get: function(variable) {
              return [variable];
            }
          };
        }
        variableEquivalencies = equivalencies.get(variable);
        results = [];
        for (_i = 0, _len = sourceExpressions.length; _i < _len; _i++) {
          expression = sourceExpressions[_i];
          childrenExpressions = [];
          _ref = this.children;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            child = _ref[_j];
            if (child instanceof terminals.Variable && (child.label === variable || (_ref1 = child.label, __indexOf.call(variableEquivalencies, _ref1) >= 0))) {
              childrenExpressions.push([expression.copy()]);
            } else if (child.substituteExpression != null) {
              childrenExpressions.push(child.substituteExpression(expression, variable, equivalencies));
            } else {
              childrenExpressions.push([child.copy()]);
            }
          }
          console.log("childrenExpressions", childrenExpressions);
          childrenArray = combinations(childrenExpressions);
          console.log("childrenArray", childrenArray);
          for (_k = 0, _len2 = childrenArray.length; _k < _len2; _k++) {
            children = childrenArray[_k];
            newMul = (function(func, args, ctor) {
              ctor.prototype = func.prototype;
              var child = new ctor, result = func.apply(child, args);
              return Object(result) === result ? result : child;
            })(Mul, children, function(){});
            results.push(newMul.expandAndSimplify(equivalencies));
          }
        }
        console.log(results);
        return results;
      };

      Mul.prototype.toDrawingNode = function() {
        var Pow, bottom, child, newBottom, power, top, _i, _len, _ref, _ref1, _ref2;
        Pow = require("operators/Pow");
        terminals = require("terminals");
        top = [];
        bottom = [];
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child instanceof Pow) {
            power = child.children.right;
            if (power instanceof terminals.Constant) {
              if (power.denominator < 0) {
                power.denominator *= -1;
                power.numerator *= -1;
              }
              if (power.numerator < 0) {
                bottom.push(new Pow(child.children.left, new terminals.Constant(power.numerator, -power.denominator)).toDrawingNode());
              } else {
                top.push(child.toDrawingNode());
              }
            } else {
              top.push(child.toDrawingNode());
            }
          } else if (child instanceof terminals.Constant) {
            if (child.numerator !== 1) {
              top.unshift(new prettyRender.Number(child.numerator));
            }
            if (child.denominator !== 1) {
              bottom.unshift(new prettyRender.Number(child.denominator));
            }
          } else {
            top.push(child.toDrawingNode());
          }
        }
        if (bottom.length === 1) {
          newBottom = bottom[0];
        } else if (bottom.length > 1) {
          newBottom = (_ref1 = prettyRender.Mul).makeWithBrackets.apply(_ref1, bottom);
        }
        if (top.length === 1) {
          top = top[0];
        } else if (top.length > 1) {
          top = (_ref2 = prettyRender.Mul).makeWithBrackets.apply(_ref2, top);
        }
        if (bottom.length === 0) {
          return top;
        } else if (top.length === 0) {
          return new prettyRender.Fraction(new prettyRender.Number(1), newBottom);
        } else {
          return new prettyRender.Fraction(top, newBottom);
        }
      };

      Mul.prototype.differentiate = function(variable) {
        var Add, f, g;
        Add = require("operators/Add");
        if (this.children.length === 0) {
          throw new Error("I'm pretty sure you need children in your Mul node");
        }
        if (this.children.length === 1) {
          return this.children[0].differentiate(variable).expandAndSimplify();
        } else {
          f = this.children[0];
          g = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(Mul, this.children.slice(1), function(){});
          return new Add(new Mul(f, g.differentiate(variable)), new Mul(g, f.differentiate(variable))).expandAndSimplify();
        }
      };

      return Mul;

    })(nodes.RoseNode);
    return Mul;
  });

}).call(this);
