// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(["parse", "nodes", "prettyRender", "constants"], function(parse, nodes, prettyRender, constants) {
    var Constant, SymbolicConstant, Terminal, Uncertainty, Variable, _ref;
    Terminal = (function(_super) {
      __extends(Terminal, _super);

      function Terminal() {
        _ref = Terminal.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      Terminal.prototype.evaluate = function() {
        throw new Error("Not implemented.");
      };

      Terminal.prototype.copy = function() {
        throw new Error("Not implemented.");
      };

      return Terminal;

    })(nodes.BasicNode);
    Constant = (function(_super) {
      __extends(Constant, _super);

      function Constant(numerator, denominator, mode) {
        this.numerator = numerator;
        this.denominator = denominator != null ? denominator : 1;
        this.mode = mode != null ? mode : "rational";
        this.cmp = -6;
        switch (this.mode) {
          case "rational":
            this.numerator = parseInt(this.numerator);
            this.denominator = parseInt(this.denominator);
            this.simplifyInPlace();
            break;
          case "float":
            this.numerator = parseFloat(this.numerator);
            this.denominator = parseFloat(this.denominator);
            this.numerator /= this.denominator;
            this.denominator = 1;
        }
      }

      Constant.prototype.evaluate = function() {
        return parseFloat(this.numerator / this.denominator);
      };

      Constant.prototype.copy = function() {
        return new Constant(this.numerator, this.denominator, this.mode);
      };

      Constant.prototype.compareSameType = function(b) {
        if (this.evaluate() < b.evaluate()) {
          return -1;
        } else if (this.evaluate() === b.evaluate()) {
          return 0;
        } else {
          return 1;
        }
      };

      Constant.prototype.mul = function(b) {
        var newMode;
        if (this.mode === b.mode) {
          newMode = this.mode;
        } else {
          newMode = "float";
        }
        return new Constant(this.numerator * b.numerator, this.denominator * b.denominator, newMode);
      };

      Constant.prototype.add = function(b) {
        var newMode;
        if (this.mode === b.mode) {
          newMode = this.mode;
        } else {
          newMode = "float";
        }
        return new Constant(b.denominator * this.numerator + this.denominator * b.numerator, this.denominator * b.denominator, newMode);
      };

      Constant.prototype.pow = function(b) {
        var con, den, flip, num, operators;
        if (this.mode === "rational") {
          if (b.mode === "rational") {
            flip = false;
            if (b.numerator < 0 && b.denominator < 0) {
              b = new Constant(-b.numerator, -b.denominator);
            } else if (b.numerator > 0 && b.denominator < 0) {
              flip = true;
              b = new Constant(b.numerator, -b.denominator);
            } else if (b.numerator < 0 && b.denominator > 0) {
              flip = true;
              b = new Constant(-b.numerator, b.denominator);
            }
            num = Math.pow(this.numerator, b.numerator);
            den = Math.pow(this.denominator, b.numerator);
            if (flip) {
              con = new Constant(den, num, "rational");
            } else {
              con = new Constant(num, den, "rational");
            }
            if (b.denominator === 1) {
              return con;
            } else {
              operators = require("operators");
              return new operators.Pow(con, new Constant(1, b.denominator, "rational"));
            }
          } else {
            return new Constant(Math.pow(this.evaluate(), b.evaluate()), 1, "float");
          }
        } else {
          return new Constant(Math.pow(this.evaluate(), b.evaluate()), 1, "float");
        }
      };

      Constant.prototype.equals = function(b) {
        if (!(b instanceof Constant)) {
          return false;
        }
        return this.evaluate() === b.evaluate();
      };

      Constant.prototype.replaceVariables = function(replacements) {
        return this.copy();
      };

      Constant.prototype.getAllVariables = function() {
        return [];
      };

      Constant.prototype.sub = function(substitutions, uncertaintySubstitutions) {
        return this.copy();
      };

      Constant.prototype.simplifyInPlace = function() {
        var a, b, gcd, _ref1;
        a = this.numerator;
        b = this.denominator;
        while (b !== 0) {
          _ref1 = [b, Math.round(a % b * 10) / 10], a = _ref1[0], b = _ref1[1];
        }
        gcd = a;
        this.numerator /= gcd;
        this.numerator = Math.round(this.numerator * 10) / 10;
        this.denominator /= gcd;
        return this.denominator = Math.round(this.denominator * 10) / 10;
      };

      Constant.prototype.simplify = function() {
        var constant;
        constant = this.copy();
        constant.simplifyInPlace();
        return constant;
      };

      Constant.prototype.expand = function() {
        return this.copy();
      };

      Constant.prototype.expandAndSimplify = function() {
        return this.simplify();
      };

      Constant.prototype.substituteExpression = function(sourceExpression, variable, equivalencies) {
        return [this.copy()];
      };

      Constant.prototype.getUncertainty = function() {
        return new Constant(0);
      };

      Constant.prototype.getVariableUnits = function() {
        return null;
      };

      Constant.prototype.setVariableUnits = function(variable, equivalencies, units) {};

      Constant.prototype.toDrawingNode = function() {
        var FractionNode, NumberNode;
        NumberNode = prettyRender.Number;
        FractionNode = prettyRender.Fraction;
        if (this.denominator === 1) {
          return new NumberNode(this.numerator);
        }
        return new FractionNode(new NumberNode(this.numerator), new NumberNode(this.denominator));
      };

      Constant.prototype.differentiate = function(variable) {
        return new Constant(0);
      };

      return Constant;

    })(Terminal);
    SymbolicConstant = (function(_super) {
      __extends(SymbolicConstant, _super);

      function SymbolicConstant(label, value, units) {
        this.label = label;
        this.value = value != null ? value : null;
        this.units = units != null ? units : null;
        this.cmp = -5;
      }

      SymbolicConstant.prototype.copy = function() {
        return new SymbolicConstant(this.label, this.value, this.units);
      };

      SymbolicConstant.prototype.compareSameType = function(b) {
        if (this.label < b.label) {
          return -1;
        } else if (this.label === b.label) {
          return 0;
        } else {
          return 1;
        }
      };

      SymbolicConstant.prototype.evaluate = function() {
        if (this.value != null) {
          return this.value;
        }
        if (this.label in constants) {
          return constants[this.label];
        }
        return null;
      };

      SymbolicConstant.prototype.equals = function(b) {
        if (!(b instanceof SymbolicConstant)) {
          return false;
        }
        return this.label === b.label && this.value === b.value;
      };

      SymbolicConstant.prototype.replaceVariables = function(replacements) {
        return this.copy();
      };

      SymbolicConstant.prototype.getAllVariables = function() {
        return [];
      };

      SymbolicConstant.prototype.sub = function(substitutions, uncertaintySubstitutions, equivalencies, assumeZeroUncertainty, evaluateSymbolicConstants) {
        if (equivalencies == null) {
          equivalencies = null;
        }
        if (assumeZeroUncertainty == null) {
          assumeZeroUncertainty = false;
        }
        if (evaluateSymbolicConstants == null) {
          evaluateSymbolicConstants = false;
        }
        if (!evaluateSymbolicConstants) {
          return this.copy();
        }
        if (this.value != null) {
          return new Constant(this.value);
        }
        if (this.label in constants) {
          return new Constant(constants[this.label]);
        }
        return this.copy();
      };

      SymbolicConstant.prototype.simplify = function() {
        return this.copy();
      };

      SymbolicConstant.prototype.expand = function() {
        return this.copy();
      };

      SymbolicConstant.prototype.expandAndSimplify = function() {
        return this.copy();
      };

      SymbolicConstant.prototype.substituteExpression = function(sourceExpression, variable, equivalencies) {
        return [this.copy()];
      };

      SymbolicConstant.prototype.getUncertainty = function() {
        return new Constant(0);
      };

      SymbolicConstant.prototype.getVariableUnits = function(variable) {
        return null;
      };

      SymbolicConstant.prototype.setVariableUnits = function(variable, equivalencies, units) {
        return null;
      };

      SymbolicConstant.prototype.toDrawingNode = function() {
        var VariableNode;
        VariableNode = prettyRender.Variable;
        return new VariableNode(this.label, "constant symbolic-constant");
      };

      SymbolicConstant.prototype.differentiate = function(variable) {
        return new Constant(0);
      };

      return SymbolicConstant;

    })(Terminal);
    Variable = (function(_super) {
      __extends(Variable, _super);

      function Variable(label, units) {
        this.label = label;
        this.units = units != null ? units : null;
        this.cmp = -4;
      }

      Variable.prototype.copy = function() {
        return new Variable(this.label, this.units);
      };

      Variable.prototype.compareSameType = function(b) {
        if (this.label < b.label) {
          return -1;
        } else if (this.label === b.label) {
          return 0;
        } else {
          return 1;
        }
      };

      Variable.prototype.equals = function(b, equivalencies) {
        var _ref1;
        if (equivalencies == null) {
          equivalencies = null;
        }
        if (!(b instanceof Variable)) {
          return false;
        }
        if (equivalencies != null) {
          return _ref1 = this.label, __indexOf.call(equivalencies.get(b.label), _ref1) >= 0;
        } else {
          return b.label === this.label;
        }
      };

      Variable.prototype.replaceVariables = function(replacements) {
        var copy;
        copy = this.copy();
        if (this.label in replacements) {
          copy.label = replacements[this.label];
        }
        return copy;
      };

      Variable.prototype.getAllVariables = function() {
        return [this.label];
      };

      Variable.prototype.sub = function(substitutions, uncertaintySubstitutions) {
        var substitute;
        if (this.label in substitutions) {
          substitute = substitutions[this.label];
          if (substitute.copy != null) {
            return substitute.copy();
          } else {
            return new Constant(substitute);
          }
        } else {
          return this.copy();
        }
      };

      Variable.prototype.substituteExpression = function(sourceExpression, variable, equivalencies, eliminate) {
        var e, sourceExpressions, variableEquivalencies, _ref1;
        if (equivalencies == null) {
          equivalencies = null;
        }
        if (eliminate == null) {
          eliminate = false;
        }
        if (equivalencies == null) {
          equivalencies = {
            get: function(variable) {
              return [variable];
            }
          };
        }
        variableEquivalencies = equivalencies.get(variable);
        if (eliminate) {
          sourceExpressions = sourceExpression.solve(variable);
        } else {
          sourceExpressions = [sourceExpression];
        }
        if (this.label === variable || (_ref1 = this.label, __indexOf.call(variableEquivalencies, _ref1) >= 0)) {
          return (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = sourceExpressions.length; _i < _len; _i++) {
              e = sourceExpressions[_i];
              _results.push(e.copy());
            }
            return _results;
          })();
        } else {
          return [this.copy()];
        }
      };

      Variable.prototype.getUncertainty = function() {
        return new Uncertainty(this.label);
      };

      Variable.prototype.getVariableUnits = function(variable, equivalencies) {
        var _ref1;
        if (equivalencies != null) {
          if (_ref1 = this.label, __indexOf.call(equivalencies.get(variable), _ref1) >= 0) {
            return this.units;
          }
        } else if (this.label === variable) {
          return this.units;
        }
        return null;
      };

      Variable.prototype.setVariableUnits = function(variable, equivalencies, units) {
        var _ref1;
        if (equivalencies != null) {
          if (_ref1 = this.label, __indexOf.call(equivalencies.get(variable), _ref1) >= 0) {
            return this.units = units;
          }
        } else if (this.label === variable) {
          return this.units = units;
        }
      };

      Variable.prototype.simplify = function() {
        return this.copy();
      };

      Variable.prototype.expand = function() {
        return this.copy();
      };

      Variable.prototype.expandAndSimplify = function() {
        return this.copy();
      };

      Variable.prototype.toDrawingNode = function() {
        var VariableNode;
        VariableNode = prettyRender.Variable;
        return new VariableNode(this.label);
      };

      Variable.prototype.differentiate = function(variable) {
        if (variable === this.label) {
          return new Constant(1);
        }
        return new Constant(0);
      };

      return Variable;

    })(Terminal);
    Uncertainty = (function(_super) {
      __extends(Uncertainty, _super);

      function Uncertainty(label) {
        this.label = label;
        this.cmp = -4.5;
      }

      Uncertainty.prototype.copy = function() {
        return new Uncertainty(this.label);
      };

      Uncertainty.prototype.compareSameType = function(b) {
        if (this.label < b.label) {
          return -1;
        } else if (this.label === b.label) {
          return 0;
        } else {
          return 1;
        }
      };

      Uncertainty.prototype.equals = function(b, equivalencies) {
        var _ref1;
        if (equivalencies == null) {
          equivalencies = null;
        }
        if (!(b instanceof Uncertainty)) {
          return false;
        }
        if (equivalencies != null) {
          return _ref1 = this.label, __indexOf.call(equivalencies.get(b.label), _ref1) >= 0;
        } else {
          return b.label === this.label;
        }
      };

      Uncertainty.prototype.replaceVariables = function(replacements) {
        var copy;
        copy = this.copy();
        if (this.label in replacements) {
          copy.label = replacements[this.label];
        }
        return copy;
      };

      Uncertainty.prototype.getAllVariables = function() {
        return [this.label];
      };

      Uncertainty.prototype.sub = function(substitutions, uncertaintySubstitutions, equivalencies, assumeZero) {
        var substitute;
        if (equivalencies == null) {
          equivalencies = null;
        }
        if (assumeZero == null) {
          assumeZero = false;
        }
        if (this.label in uncertaintySubstitutions && (uncertaintySubstitutions[this.label] != null)) {
          substitute = uncertaintySubstitutions[this.label];
          if (substitute.copy != null) {
            return substitute.copy();
          } else {
            return new Constant(substitute);
          }
        } else {
          if (!assumeZero) {
            return this.copy();
          } else {
            return new Constant("0");
          }
        }
      };

      Uncertainty.prototype.substituteExpression = function(sourceExpression, variable, equivalencies, eliminate) {
        if (equivalencies == null) {
          equivalencies = null;
        }
        if (eliminate == null) {
          eliminate = false;
        }
        throw new Error("Can't sub uncertainties");
      };

      Uncertainty.prototype.getUncertainty = function() {
        throw new Error("Can't take uncertainty of an uncertainty");
      };

      Uncertainty.prototype.getVariableUnits = function(variable, equivalencies) {
        throw new Error("Can't do that with uncertainties");
      };

      Uncertainty.prototype.setVariableUnits = function(variable, equivalencies, units) {
        throw new Error("Can't do that with uncertainties");
      };

      Uncertainty.prototype.simplify = function() {
        return this.copy();
      };

      Uncertainty.prototype.expand = function() {
        return this.copy();
      };

      Uncertainty.prototype.expandAndSimplify = function() {
        return this.copy();
      };

      Uncertainty.prototype.toDrawingNode = function() {
        var UncertaintyNode;
        UncertaintyNode = prettyRender.Uncertainty;
        return new UncertaintyNode(this.label);
      };

      Uncertainty.prototype.differentiate = function(variable) {
        throw new Error("Can't differentiate uncertainties!");
      };

      return Uncertainty;

    })(Terminal);
    return {
      Terminal: Terminal,
      Variable: Variable,
      Constant: Constant,
      SymbolicConstant: SymbolicConstant,
      Uncertainty: Uncertainty
    };
  });

}).call(this);
