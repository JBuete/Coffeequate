// Generated by CoffeeScript 1.9.3
var slice = [].slice;

define(["parse", "nodes"], function(parse, nodes) {
  var Expression;
  Expression = (function() {
    function Expression(val) {
      if (val instanceof String || typeof val === "string") {
        this.expr = parse.stringToExpression(val);
        if (this.expr.simplify != null) {
          this.expr = this.expr.simplify();
        }
      } else if (val.copy != null) {
        this.expr = val.copy().simplify();
      } else {
        console.log("Received argument: ", val);
        throw new Error("Unknown argument: `" + val + "'.");
      }
    }

    Expression.prototype.toString = function() {
      return this.expr.toString();
    };

    Expression.prototype.toMathML = function() {
      return this.expr.toMathML();
    };

    Expression.prototype.toLaTeX = function() {
      return this.expr.toLaTeX();
    };

    Expression.prototype.solve = function(variable, equivalencies) {
      var i, len, ref, results, solution;
      if (equivalencies == null) {
        equivalencies = {};
      }
      ref = this.expr.solve(variable, equivalencies);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        solution = ref[i];
        results.push(new Expression(solution));
      }
      return results;
    };

    Expression.prototype.sub = function(substitutions, equivalencies, substituteUncertainties, evaluateSymbolicConstants) {
      var key, newsubs, subbed, uncertaintySubs, variableSubs;
      if (equivalencies == null) {
        equivalencies = {};
      }
      if (substituteUncertainties == null) {
        substituteUncertainties = false;
      }
      if (evaluateSymbolicConstants == null) {
        evaluateSymbolicConstants = false;
      }
      newsubs = {};
      for (key in substitutions) {
        if (substitutions[key] instanceof Expression) {
          newsubs[key] = substitutions[key].expr;
        } else {
          newsubs[key] = substitutions[key];
        }
      }
      if (substituteUncertainties) {
        uncertaintySubs = newsubs;
        variableSubs = {};
      } else {
        uncertaintySubs = {};
        variableSubs = newsubs;
      }
      subbed = this.expr.sub(variableSubs, uncertaintySubs, equivalencies, false, evaluateSymbolicConstants);
      if (subbed.simplify != null) {
        subbed = subbed.simplify(equivalencies);
      }
      return new Expression(subbed);
    };

    Expression.prototype.getAllVariables = function() {
      return this.expr.getAllVariables();
    };

    Expression.prototype.mapOverVariables = function(fun) {
      return this.expr.mapOverVariables(fun);
    };

    Expression.prototype.copy = function() {
      return new Expression(this.expr.copy());
    };

    Expression.prototype.simplify = function(equivalencies) {
      var expr;
      if (equivalencies == null) {
        equivalencies = {};
      }
      if (this.expr.expandAndSimplify != null) {
        expr = this.expr.expandAndSimplify(equivalencies);
      } else if (this.expr.simplify != null) {
        expr = this.expr.simplify(equivalencies);
      } else {
        expr = this.expr.copy();
      }
      return new Expression(expr);
    };

    Expression.prototype.expand = function() {
      var expr;
      if (this.expr.expand != null) {
        expr = this.expr.expand();
      } else {
        expr = this.expr.copy();
      }
      return new Expression(expr);
    };

    Expression.prototype.differentiate = function(variable, equivalencies) {
      if (equivalencies == null) {
        equivalencies = {};
      }
      return new Expression(this.expr.differentiate(variable, equivalencies));
    };

    Expression.prototype.getUncertainty = function() {
      return new Expression(this.expr.getUncertainty());
    };

    Expression.prototype.toFunction = function() {
      var equivalencies, fun, i, variables;
      variables = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), equivalencies = arguments[i++];
      if (typeof equivalencies === "string" || equivalencies instanceof String) {
        variables.push(equivalencies);
        equivalencies = {};
      }
      fun = (function(_this) {
        return function() {
          var index, j, len, subs, substitutions, variable;
          subs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          substitutions = {};
          for (index = j = 0, len = variables.length; j < len; index = ++j) {
            variable = variables[index];
            if (subs[index] != null) {
              substitutions[variable] = subs[index];
            }
          }
          return _this.sub(substitutions, equivalencies);
        };
      })(this);
      return fun;
    };

    Expression.prototype.approx = function() {
      return this.expr.approx();
    };

    Expression.prototype.equals = function(other, equivalencies) {
      var lhs, rhs;
      if (equivalencies == null) {
        equivalencies = {};
      }
      if (!(other instanceof Expression)) {
        return void 0;
      }
      lhs = this.expr.expandAndSimplify(equivalencies);
      rhs = other.expr.expandAndSimplify(equivalencies);
      return lhs.equals(rhs);
    };

    Expression.prototype.nsolve = function(guess, variable, equivalencies, tol, max_iterations) {
      var diff, f, f0, f1, fDash, i, iteration, p0, p1, ref;
      if (equivalencies == null) {
        equivalencies = {};
      }
      if (tol == null) {
        tol = 1e-9;
      }
      if (max_iterations == null) {
        max_iterations = 75;
      }
      p0 = guess;
      f = this.toFunction("x");
      diff = this.differentiate(variable, equivalencies);
      fDash = diff.toFunction("x");
      for (iteration = i = 0, ref = max_iterations; 0 <= ref ? i < ref : i > ref; iteration = 0 <= ref ? ++i : --i) {
        f1 = fDash(p0).approx();
        if (f1 === 0) {
          console.log("The derivative is zero");
          return p0;
        }
        f0 = f(p0).approx();
        p1 = p0 - (f0 / f1);
        if (Math.abs(p1 - p0) < tol) {
          return p1;
        }
        p0 = p1;
      }
      throw new Error("Maximum Number of Iterations Reached");
      return p1;
    };

    return Expression;

  })();
  return Expression;
});
